var N=Object.defineProperty;var S=l=>{throw TypeError(l)};var $=(l,i,s)=>i in l?N(l,i,{enumerable:!0,configurable:!0,writable:!0,value:s}):l[i]=s;var o=(l,i,s)=>$(l,typeof i!="symbol"?i+"":i,s),B=(l,i,s)=>i.has(l)||S("Cannot "+s);var A=(l,i,s)=>i.has(l)?S("Cannot add the same private member more than once"):i instanceof WeakSet?i.add(l):i.set(l,s);var u=(l,i,s)=>(B(l,i,"access private method"),s);import{G as U,r as m,f as H,j as k,k as b,S as p,l as M,m as x,n as z,o as Y,p as G,q as K,t as W,u as X,v as J,w as V,e as Z,B as ee,D as se,d as te}from"./FacadeVFS-B_tdUAGv.js";const ae=10,re=1e3,w=["","-journal","-wal"],ne=new FinalizationRegistry(l=>l());class L{constructor(i,s){o(this,"path");o(this,"flags");o(this,"accessHandle");o(this,"persistentFile");this.path=i,this.flags=s}}class O{constructor(i){o(this,"fileHandle");o(this,"accessHandle",null);o(this,"isLockBusy",!1);o(this,"isFileLocked",!1);o(this,"isRequestInProgress",!1);o(this,"handleLockReleaser",null);o(this,"handleRequestChannel");o(this,"isHandleRequested",!1);this.fileHandle=i}}var h,v,C,I,f,Q;const T=class T extends U{constructor(s,t){super(s,t);A(this,h);o(this,"mapIdToFile",new Map);o(this,"lastError",null);o(this,"log",null);o(this,"persistentFiles",new Map);o(this,"boundAccessHandles",new Map);o(this,"unboundAccessHandles",new Set);o(this,"accessiblePaths",new Set);o(this,"releaser",null)}static async create(s,t){var a;const e=new T(s,t);return await Promise.all([e.isReady(),u(a=e,h,v).call(a,ae)]),e}jOpen(s,t,e,a){var r;try{const n=new URL(s||Math.random().toString(36).slice(2),"file://").pathname;if(e&m){const F=this.persistentFiles.get(n);if(F!=null&&F.isRequestInProgress)return H;if(F)if(F.fileHandle){if(!F.accessHandle)return this._module.retryOps.push((async()=>{const E=new L(n,e);E.persistentFile=this.persistentFiles.get(n),await u(this,h,I).call(this,E)})()),H}else return this.persistentFiles.delete(n),b;else{(r=this.log)==null||r.call(this,`creating persistent file for ${n}`);const E=!!(e&k);return this._module.retryOps.push((async()=>{try{let g=await navigator.storage.getDirectory();const R=n.split("/").filter(y=>y),j=R.pop();for(const y of R)g=await g.getDirectoryHandle(y,{create:E});for(const y of w){const D=await g.getFileHandle(j+y,{create:E});await u(this,h,C).call(this,D)}const _=new L(n,e);_.persistentFile=this.persistentFiles.get(n),await u(this,h,I).call(this,_)}catch(g){const R=new O(null);this.persistentFiles.set(n,R),console.error(g)}})()),H}}if(!this.accessiblePaths.has(n)&&!(e&k))throw new Error(`File ${n} not found`);const d=new L(n,e);return this.mapIdToFile.set(t,d),this.persistentFiles.has(n)?d.persistentFile=this.persistentFiles.get(n):this.boundAccessHandles.has(n)?d.accessHandle=this.boundAccessHandles.get(n):this.unboundAccessHandles.size&&(d.accessHandle=this.unboundAccessHandles.values().next().value,d.accessHandle.truncate(0),this.unboundAccessHandles.delete(d.accessHandle),this.boundAccessHandles.set(n,d.accessHandle)),this.accessiblePaths.add(n),a.setInt32(0,e,!0),p}catch(c){return this.lastError=c,b}}jDelete(s,t){var e;try{const r=new URL(s,"file://").pathname;return this.persistentFiles.has(r)?this.persistentFiles.get(r).accessHandle.truncate(0):(e=this.boundAccessHandles.get(r))==null||e.truncate(0),this.accessiblePaths.delete(r),p}catch(a){return this.lastError=a,M}}jAccess(s,t,e){try{const r=new URL(s,"file://").pathname;return e.setInt32(0,this.accessiblePaths.has(r)?1:0,!0),p}catch(a){return this.lastError=a,x}}jClose(s){var t;try{const e=this.mapIdToFile.get(s);return this.mapIdToFile.delete(s),(e==null?void 0:e.flags)&m?(t=e.persistentFile)!=null&&t.handleLockReleaser&&u(this,h,f).call(this,e):(e==null?void 0:e.flags)&z&&(e.accessHandle.truncate(0),this.accessiblePaths.delete(e.path),this.persistentFiles.has(e.path)||(this.boundAccessHandles.delete(e.path),this.unboundAccessHandles.add(e.accessHandle))),p}catch(e){return this.lastError=e,Y}}jRead(s,t,e){try{const a=this.mapIdToFile.get(s),c=(a.accessHandle||a.persistentFile.accessHandle).read(t.subarray(),{at:e});return a.flags&m&&!a.persistentFile.isFileLocked&&u(this,h,f).call(this,a),c<t.byteLength?(t.fill(0,c),G):p}catch(a){return this.lastError=a,K}}jWrite(s,t,e){try{const a=this.mapIdToFile.get(s);if((a.accessHandle||a.persistentFile.accessHandle).write(t.subarray(),{at:e})!==t.byteLength)throw new Error("short write");return p}catch(a){return this.lastError=a,W}}jTruncate(s,t){try{const e=this.mapIdToFile.get(s);return(e.accessHandle||e.persistentFile.accessHandle).truncate(t),p}catch(e){return this.lastError=e,X}}jSync(s,t){try{const e=this.mapIdToFile.get(s);return(e.accessHandle||e.persistentFile.accessHandle).flush(),p}catch(e){return this.lastError=e,J}}jFileSize(s,t){try{const e=this.mapIdToFile.get(s),r=(e.accessHandle||e.persistentFile.accessHandle).getSize();return t.setBigInt64(0,BigInt(r),!0),p}catch(e){return this.lastError=e,V}}jLock(s,t){var a;const e=this.mapIdToFile.get(s);return e.persistentFile.isRequestInProgress?(e.persistentFile.isLockBusy=!0,H):(e.persistentFile.isFileLocked=!0,e.persistentFile.handleLockReleaser?(e.persistentFile.isLockBusy=!1,p):(e.persistentFile.handleRequestChannel.onmessage=()=>{var r;(r=this.log)==null||r.call(this,`received notification for ${e.path}`),e.persistentFile.isFileLocked?e.persistentFile.isHandleRequested=!0:u(this,h,f).call(this,e),e.persistentFile.handleRequestChannel.onmessage=null},u(this,h,I).call(this,e),(a=this.log)==null||a.call(this,"returning SQLITE_BUSY"),e.persistentFile.isLockBusy=!0,H))}jUnlock(s,t){const e=this.mapIdToFile.get(s);return t===Z&&(e.persistentFile.isLockBusy||(e.persistentFile.isHandleRequested&&(u(this,h,f).call(this,e),e.persistentFile.isHandleRequested=!1),e.persistentFile.isFileLocked=!1)),p}jFileControl(s,t,e){var a;try{const r=this.mapIdToFile.get(s);switch(t){case ee:const c=q(e,4),n=q(e,8);switch((a=this.log)==null||a.call(this,"xFileControl",r.path,"PRAGMA",c,n),c.toLowerCase()){case"journal_mode":if(n&&!["off","memory","delete","wal"].includes(n.toLowerCase()))throw new Error('journal_mode must be "off", "memory", "delete", or "wal"');break}break}}catch(r){return this.lastError=r,se}return te}jGetLastError(s){if(this.lastError){console.error(this.lastError);const t=s.subarray(0,s.byteLength-1),{written:e}=new TextEncoder().encodeInto(this.lastError.message,t);s[e]=0}return p}};h=new WeakSet,v=async function(s){const t=await navigator.storage.getDirectory();for await(const r of t.values())r.kind==="directory"&&r.name.startsWith(".ahp-")&&await navigator.locks.request(r.name,{ifAvailable:!0},async c=>{var n,d;c?((n=this.log)==null||n.call(this,`Deleting temporary directory ${r.name}`),await t.removeEntry(r.name,{recursive:!0})):(d=this.log)==null||d.call(this,`Temporary directory ${r.name} is in use`)});const e=`.ahp-${Math.random().toString(36).slice(2)}`;this.releaser=await new Promise(r=>{navigator.locks.request(e,()=>new Promise(c=>{r(c)}))}),ne.register(this,this.releaser);const a=await t.getDirectoryHandle(e,{create:!0});for(let r=0;r<s;r++){const n=await(await a.getFileHandle(`${r}.tmp`,{create:!0})).createSyncAccessHandle();this.unboundAccessHandles.add(n)}},C=async function(s){const t=new O(s),r=`/${(await(await navigator.storage.getDirectory()).resolve(s)).join("/")}`;return t.handleRequestChannel=new BroadcastChannel(`ahp:${r}`),this.persistentFiles.set(r,t),(await s.getFile()).size&&this.accessiblePaths.add(r),t},I=function(s){return console.assert(!s.persistentFile.handleLockReleaser),s.persistentFile.isRequestInProgress?Promise.resolve():(s.persistentFile.isRequestInProgress=!0,this._module.retryOps.push((async()=>{var t,e;s.persistentFile.handleLockReleaser=await u(this,h,Q).call(this,s.persistentFile);try{(t=this.log)==null||t.call(this,`creating access handles for ${s.path}`),await Promise.all(w.map(async a=>{const r=this.persistentFiles.get(s.path+a);r&&(r.accessHandle=await r.fileHandle.createSyncAccessHandle())}))}catch(a){throw(e=this.log)==null||e.call(this,`failed to create access handles for ${s.path}`,a),u(this,h,f).call(this,s),a}finally{s.persistentFile.isRequestInProgress=!1}})()),this._module.retryOps.at(-1))},f=async function(s){var t,e,a,r;w.forEach(async c=>{var d;const n=this.persistentFiles.get(s.path+c);n&&((d=n.accessHandle)==null||d.close(),n.accessHandle=null)}),(t=this.log)==null||t.call(this,`access handles closed for ${s.path}`),(a=(e=s.persistentFile).handleLockReleaser)==null||a.call(e),s.persistentFile.handleLockReleaser=null,(r=this.log)==null||r.call(this,`lock released for ${s.path}`)},Q=function(s){return new Promise(t=>{var c;const e=s.handleRequestChannel.name,a=()=>{var n;(n=this.log)==null||n.call(this,`notifying for ${e}`),s.handleRequestChannel.postMessage(null)},r=setInterval(a,re);setTimeout(a),(c=this.log)==null||c.call(this,`lock requested: ${e}`),navigator.locks.request(e,n=>{var d;return(d=this.log)==null||d.call(this,`lock acquired: ${e}`,n),clearInterval(r),new Promise(t)})})};let P=T;function q(l,i){const s=l.getUint32(i,!0);if(s){const t=new Uint8Array(l.buffer,s);return new TextDecoder().decode(t.subarray(0,t.indexOf(0)))}return null}export{P as OPFSCoopSyncVFS};
