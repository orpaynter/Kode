var ue=Object.defineProperty;var S=d=>{throw TypeError(d)};var de=(d,h,t)=>h in d?ue(d,h,{enumerable:!0,configurable:!0,writable:!0,value:t}):d[h]=t;var m=(d,h,t)=>de(d,typeof h!="symbol"?h+"":h,t),H=(d,h,t)=>h.has(d)||S("Cannot "+t);var c=(d,h,t)=>(H(d,h,"read from private field"),t?t.call(d):h.get(d)),T=(d,h,t)=>h.has(d)?S("Cannot add the same private member more than once"):h instanceof WeakSet?h.add(d):h.set(d,t),C=(d,h,t,s)=>(H(d,h,"write to private field"),s?s.call(d,t):h.set(d,t),t),E=(d,h,t)=>(H(d,h,"access private method"),t);import{F as fe}from"./FacadeVFS-D1q6Xq-i.js";import{S as w,a as Ee,b as ye,c as Ie,d as ge,e as Q,f as x,g as z,h as V,i as $,j as we,k as be,l as pe,m as me,n as _e,o as Le,p as Te,q as Oe,r as N,s as Re,t as Ce,u as xe,v as ve,w as Pe,x as Fe,y as je,z as Ae,A as Me,B as Ne,C as k,D as Qe,E as De,F as qe}from"./index-BNVl7HfL.js";const B={mode:"shared"},Be={ifAvailable:!0,mode:"shared"},ee={ifAvailable:!0,mode:"exclusive"},We=["exclusive","shared","shared+hint"],W=d=>{var h,t,s,D,re,ne,ae,ie,oe,ce,_,b;return b=class extends d{constructor(e,a,o){super(e,a,o);T(this,s);T(this,h,{lockPolicy:"exclusive",lockTimeout:1/0});T(this,t,new Map);if(Object.assign(c(this,h),o),We.indexOf(c(this,h).lockPolicy)===-1)throw new Error(`WebLocksMixin: invalid lock mode: ${o.lockPolicy}`)}async jLock(e,a){try{const o=E(this,s,D).call(this,e);if(a<=o.type)return w;switch(c(this,h).lockPolicy){case"exclusive":return await E(this,s,re).call(this,o,a);case"shared":case"shared+hint":return await E(this,s,ie).call(this,o,a)}}catch(o){return console.error("WebLocksMixin: lock error",o),Ee}}async jUnlock(e,a){try{const o=E(this,s,D).call(this,e);if(!(a<o.type))return w;switch(c(this,h).lockPolicy){case"exclusive":return await E(this,s,ne).call(this,o,a);case"shared":case"shared+hint":return await E(this,s,oe).call(this,o,a)}}catch(o){return console.error("WebLocksMixin: unlock error",o),ye}}async jCheckReservedLock(e,a){try{const o=E(this,s,D).call(this,e);switch(c(this,h).lockPolicy){case"exclusive":return E(this,s,ae).call(this,o,a);case"shared":case"shared+hint":return await E(this,s,ce).call(this,o,a)}}catch(o){return console.error("WebLocksMixin: check reserved lock error",o),Ie}return a.setInt32(0,0,!0),w}jFileControl(e,a,o){if(a===W.WRITE_HINT_OP_CODE&&c(this,h).lockPolicy==="shared+hint"){const I=E(this,s,D).call(this,e);I.writeHint=!0}return ge}},h=new WeakMap,t=new WeakMap,s=new WeakSet,D=function(e){let a=c(this,t).get(e);return a||(a={baseName:this.getFilename(e),type:Q,writeHint:!1},c(this,t).set(e,a)),a},re=async function(e,a){if(!e.access){if(!await E(this,s,_).call(this,e,"access"))return x;console.assert(!!e.access)}return e.type=a,w},ne=function(e,a){var o;return a===Q&&((o=e.access)==null||o.call(e),console.assert(!e.access)),e.type=a,w},ae=function(e,a){return a.setInt32(0,0,!0),w},ie=async function(e,a){var o,I;switch(e.type){case Q:switch(a){case $:if(e.writeHint&&!await E(this,s,_).call(this,e,"hint"))return x;if(!await E(this,s,_).call(this,e,"gate",B))return(o=e.hint)==null||o.call(e),x;await E(this,s,_).call(this,e,"access",B),e.gate(),console.assert(!e.gate),console.assert(!!e.access),console.assert(!e.reserved);break;default:throw new Error("unsupported lock transition")}break;case $:switch(a){case z:if(c(this,h).lockPolicy==="shared+hint"&&!e.hint&&!await E(this,s,_).call(this,e,"hint",ee))return x;if(!await E(this,s,_).call(this,e,"reserved",ee))return(I=e.hint)==null||I.call(e),x;e.access(),console.assert(!e.gate),console.assert(!e.access),console.assert(!!e.reserved);break;case V:if(!await E(this,s,_).call(this,e,"gate"))return x;if(e.access(),!await E(this,s,_).call(this,e,"access"))return e.gate(),x;console.assert(!!e.gate),console.assert(!!e.access),console.assert(!e.reserved);break;default:throw new Error("unsupported lock transition")}break;case z:switch(a){case V:if(!await E(this,s,_).call(this,e,"gate"))return x;if(!await E(this,s,_).call(this,e,"access"))return e.gate(),x;console.assert(!!e.gate),console.assert(!!e.access),console.assert(!!e.reserved);break;default:throw new Error("unsupported lock transition")}break}return e.type=a,w},oe=async function(e,a){var o,I,P,p,M,J,Z;if(a===Q)(o=e.access)==null||o.call(e),(I=e.gate)==null||I.call(e),(P=e.reserved)==null||P.call(e),(p=e.hint)==null||p.call(e),e.writeHint=!1,console.assert(!e.access),console.assert(!e.gate),console.assert(!e.reserved),console.assert(!e.hint);else switch(e.type){case V:e.access(),await E(this,s,_).call(this,e,"access",B),e.gate(),(M=e.reserved)==null||M.call(e),(J=e.hint)==null||J.call(e),console.assert(!!e.access),console.assert(!e.gate),console.assert(!e.reserved);break;case z:await E(this,s,_).call(this,e,"access",B),e.reserved(),(Z=e.hint)==null||Z.call(e),console.assert(!!e.access),console.assert(!e.gate),console.assert(!e.reserved);break}return e.type=a,w},ce=async function(e,a){return await E(this,s,_).call(this,e,"reserved",Be)?(e.reserved(),a.setInt32(0,0,!0)):a.setInt32(0,1,!0),w},_=function(e,a,o={}){return console.assert(!e[a]),new Promise(I=>{if(!o.ifAvailable&&c(this,h).lockTimeout<1/0){const p=new AbortController;o=Object.assign({},o,{signal:p.signal}),setTimeout(()=>{p.abort(),I==null||I(!1)},c(this,h).lockTimeout)}const P=`lock##${e.baseName}##${a}`;navigator.locks.request(P,o,p=>{if(p)return new Promise(M=>{e[a]=()=>{M(),e[a]=null},I(!0),I=null});e[a]=null,I(!1),I=null}).catch(p=>{if(p.name!=="AbortError")throw p})})},b};W.WRITE_HINT_OP_CODE=-9999;const Ke=new Set(["TransactionInactiveError","InvalidStateError"]);class Ue{constructor(h,t,s){m(this,"path");m(this,"flags");m(this,"metadata");m(this,"fileSize",0);m(this,"needsMetadataSync",!1);m(this,"rollback",null);m(this,"changedPages",new Set);m(this,"synchronous","full");m(this,"txOptions",{durability:"strict"});this.path=h,this.flags=t,this.metadata=s}}var q,y,K,he;const Y=class Y extends W(fe){constructor(t,s,r={}){super(t,s,r);T(this,K);m(this,"mapIdToFile",new Map);m(this,"lastError",null);m(this,"log",null);T(this,q);T(this,y);C(this,q,E(this,K,he).call(this,r.idbName??t))}static async create(t,s,r){const n=new Y(t,s,r);return await n.isReady(),n}close(){c(this,y).close()}async isReady(){await super.isReady(),await c(this,q)}getFilename(t){const s=this.mapIdToFile.get(t).path;return`IDB(${this.name}):${s}`}async jOpen(t,s,r,n){try{const u=new URL(t||Math.random().toString(36).slice(2),"file://").pathname;let l=await c(this,y).q(({metadata:i})=>i.get(u));if(!l&&r&we&&(l={name:u,fileSize:0,version:0},await c(this,y).q(({metadata:i})=>i.put(l),"rw")),!l)throw new Error(`File ${u} not found`);const g=new Ue(u,r,l);return this.mapIdToFile.set(s,g),n.setInt32(0,r,!0),w}catch(f){return this.lastError=f,be}}async jDelete(t,s){try{const n=new URL(t,"file://").pathname;return c(this,y).q(({metadata:f,blocks:u})=>{const l=IDBKeyRange.bound([n,-1/0],[n,1/0]);u.delete(l),f.delete(n)},"rw"),s&&await c(this,y).sync(!1),w}catch(r){return this.lastError=r,pe}}async jAccess(t,s,r){try{const f=new URL(t,"file://").pathname,u=await c(this,y).q(({metadata:l})=>l.get(f));return r.setInt32(0,u?1:0,!0),w}catch(n){return this.lastError=n,me}}async jClose(t){try{const s=this.mapIdToFile.get(t);return this.mapIdToFile.delete(t),s.flags&_e&&await c(this,y).q(({metadata:r,blocks:n})=>{r.delete(s.path),n.delete(IDBKeyRange.bound([s.path,0],[s.path,1/0]))},"rw"),s.needsMetadataSync&&c(this,y).q(({metadata:r})=>r.put(s.metadata),"rw"),await c(this,y).sync(s.synchronous==="full"),w}catch(s){return this.lastError=s,Le}}async jRead(t,s,r){try{const n=this.mapIdToFile.get(t);let f=0;for(;f<s.byteLength;){const u=r+f,l=await c(this,y).q(({blocks:b})=>{const R=IDBKeyRange.bound([n.path,-u],[n.path,1/0]);return b.get(R)});if(!l||l.data.byteLength-l.offset<=u)return s.fill(0,f),Te;const g=s.subarray(f),i=u+l.offset,L=Math.min(Math.max(l.data.byteLength-i,0),g.byteLength);g.set(l.data.subarray(i,i+L)),f+=L}return w}catch(n){return this.lastError=n,Oe}}jWrite(t,s,r){try{const n=this.mapIdToFile.get(t);if(n.flags&N&&!n.rollback){const g=Object.assign({pendingVersion:n.metadata.version-1},n.metadata);c(this,y).q(({metadata:i})=>i.put(g),"rw",n.txOptions),n.rollback=Object.assign({},n.metadata),n.metadata.version--}n.flags&N&&n.changedPages.add(r);const f=s.slice(),u=n.metadata.version;if(!(r<n.metadata.fileSize)||n.flags&N||n.flags&Re){const g={path:n.path,offset:-r,version:u,data:s.slice()};c(this,y).q(({blocks:i})=>{i.put(g),n.changedPages.add(r)},"rw",n.txOptions)}else c(this,y).q(async({blocks:g})=>{const i=IDBKeyRange.bound([n.path,-r],[n.path,1/0]),L=await g.get(i);L.data.subarray(r+L.offset).set(f),g.put(L)},"rw",n.txOptions);return n.metadata.fileSize<r+s.length&&(n.metadata.fileSize=r+s.length,n.needsMetadataSync=!0),w}catch(n){return this.lastError=n,Ce}}jTruncate(t,s){try{const r=this.mapIdToFile.get(t);return s<r.metadata.fileSize&&(c(this,y).q(({blocks:n})=>{const f=IDBKeyRange.bound([r.path,-1/0],[r.path,-s,1/0]);n.delete(f)},"rw",r.txOptions),r.metadata.fileSize=s,r.needsMetadataSync=!0),w}catch(r){return this.lastError=r,xe}}async jSync(t,s){try{const r=this.mapIdToFile.get(t);return r.needsMetadataSync&&(c(this,y).q(({metadata:n})=>n.put(r.metadata),"rw",r.txOptions),r.needsMetadataSync=!1),r.flags&N?r.synchronous==="full"&&await c(this,y).sync(!0):await c(this,y).sync(r.synchronous==="full"),w}catch(r){return this.lastError=r,ve}}jFileSize(t,s){try{const r=this.mapIdToFile.get(t);return s.setBigInt64(0,BigInt(r.metadata.fileSize),!0),w}catch(r){return this.lastError=r,Pe}}async jLock(t,s){const r=this.mapIdToFile.get(t),n=await super.jLock(t,s);return s===$&&(r.metadata=await c(this,y).q(async({metadata:f,blocks:u})=>{const l=await f.get(r.path);return l.pendingVersion&&(console.warn(`removing failed transaction ${l.pendingVersion}`),await new Promise((g,i)=>{const L=IDBKeyRange.bound([l.name,-1/0],[l.name,1/0]),b=u.openCursor(L);b.onsuccess=()=>{const R=b.result;R?(R.value.version<l.version&&R.delete(),R.continue()):g()},b.onerror=()=>i(b.error)}),delete l.pendingVersion,f.put(l)),l},"rw",r.txOptions)),n}async jUnlock(t,s){if(s===Q){const r=this.mapIdToFile.get(t);await c(this,y).sync(r.synchronous==="full")}return super.jUnlock(t,s)}jFileControl(t,s,r){var n,f,u,l,g;try{const i=this.mapIdToFile.get(t);switch(s){case Ne:const L=te(r,4),b=te(r,8);(n=this.log)==null||n.call(this,"xFileControl",i.path,"PRAGMA",L,b);const R=a=>{const o=new TextEncoder().encode(a),I=this._module._sqlite3_malloc(o.byteLength);return this._module.HEAPU8.subarray(I,I+o.byteLength).set(o),r.setUint32(0,I,!0),k};switch(L.toLowerCase()){case"page_size":if(i.flags&N&&b&&i.metadata.fileSize)return k;break;case"synchronous":if(b)switch(b.toLowerCase()){case"0":case"off":i.synchronous="off",i.txOptions={durability:"relaxed"};break;case"1":case"normal":i.synchronous="normal",i.txOptions={durability:"relaxed"};break;case"2":case"3":case"full":case"extra":i.synchronous="full",i.txOptions={durability:"strict"};break}break;case"write_hint":return super.jFileControl(t,W.WRITE_HINT_OP_CODE,null)}break;case Me:if((f=this.log)==null||f.call(this,"xFileControl",i.path,"SYNC"),i.rollback){const a=Object.assign({},i.metadata),o=i.rollback.fileSize;c(this,y).q(({metadata:I,blocks:P})=>{I.put(a);for(const p of i.changedPages)if(p<o){const M=IDBKeyRange.bound([i.path,-p,a.version],[i.path,-p,1/0],!0);P.delete(M)}i.changedPages.clear()},"rw",i.txOptions),i.needsMetadataSync=!1,i.rollback=null}break;case Ae:return(u=this.log)==null||u.call(this,"xFileControl",i.path,"BEGIN_ATOMIC_WRITE"),w;case je:return(l=this.log)==null||l.call(this,"xFileControl",i.path,"COMMIT_ATOMIC_WRITE"),w;case Fe:(g=this.log)==null||g.call(this,"xFileControl",i.path,"ROLLBACK_ATOMIC_WRITE"),i.metadata=i.rollback;const e=Object.assign({},i.metadata);return c(this,y).q(({metadata:a,blocks:o})=>{a.put(e);for(const I of i.changedPages)o.delete([i.path,-I,e.version-1]);i.changedPages.clear()},"rw",i.txOptions),i.needsMetadataSync=!1,i.rollback=null,w}}catch(i){return this.lastError=i,Qe}return super.jFileControl(t,s,r)}jDeviceCharacteristics(t){return 0|De|qe}jGetLastError(t){if(this.lastError){console.error(this.lastError);const s=t.subarray(0,t.byteLength-1),{written:r}=new TextEncoder().encodeInto(this.lastError.message,s);t[r]=0}return w}};q=new WeakMap,y=new WeakMap,K=new WeakSet,he=async function(t){C(this,y,await G.create(t))};let se=Y;function te(d,h){const t=d.getUint32(h,!0);if(t){const s=new Uint8Array(d.buffer,t);return new TextDecoder().decode(s.subarray(0,s.indexOf(0)))}return null}var F,v,j,O,A,U,le;const X=class X{constructor(h){T(this,U);T(this,F);T(this,v,null);T(this,j,Promise.resolve());T(this,O,null);T(this,A,new WeakSet);m(this,"log",null);C(this,F,h)}static async create(h){const t=await new Promise((s,r)=>{const n=indexedDB.open(h,6);n.onupgradeneeded=async f=>{const u=n.result;switch(f.oldVersion&&console.log(`Upgrading IndexedDB from version ${f.oldVersion}`),f.oldVersion){case 0:u.createObjectStore("blocks",{keyPath:["path","offset","version"]}).createIndex("version",["path","version"]);case 5:const l=n.transaction;l.objectStore("blocks").deleteIndex("version");const i=u.createObjectStore("metadata",{keyPath:"name"});await new Promise((L,b)=>{let R={};const e=l.objectStore("blocks").openCursor();e.onsuccess=()=>{const a=e.result;if(a){const o=a.value;typeof o.offset!="number"||o.path===R.path&&o.offset===R.offset?a.delete():o.offset===0&&(i.put({name:o.path,fileSize:o.fileSize,version:o.version}),delete o.fileSize,a.update(o)),R=o,a.continue()}else L()},e.onerror=()=>b(e.error)});break}},n.onsuccess=()=>s(n.result),n.onerror=()=>r(n.error)});return new X(t)}close(){c(this,F).close()}q(h,t="ro",s={}){const r=t==="ro"?"readonly":"readwrite",n=Object.assign({durability:"default"},s);return C(this,v,(c(this,v)||Promise.resolve()).then(()=>E(this,U,le).call(this,h,r,n))),c(this,v)}proxyStoreOrIndex(h){return new Proxy(h,{get:(t,s,r)=>{const n=Reflect.get(t,s,r);return typeof n=="function"?(...f)=>{const u=Reflect.apply(n,t,f);return u instanceof IDBRequest&&!s.endsWith("Cursor")?(C(this,O,u),u.addEventListener("error",()=>{console.error(u.error),u.transaction.abort()},{once:!0}),He(u)):u}:n}})}async sync(h){c(this,v)&&(await c(this,v),h&&await c(this,j),this.reset())}reset(){C(this,v,null),C(this,j,Promise.resolve()),C(this,O,null)}};F=new WeakMap,v=new WeakMap,j=new WeakMap,O=new WeakMap,A=new WeakMap,U=new WeakSet,le=async function(h,t,s){var n,f;let r;c(this,O)&&c(this,A).has(c(this,O).transaction)&&c(this,O).transaction.mode>=t&&c(this,O).transaction.durability===s.durability&&(r=c(this,O).transaction,c(this,O).readyState==="pending"&&await new Promise(u=>{c(this,O).addEventListener("success",u,{once:!0}),c(this,O).addEventListener("error",u,{once:!0})}));for(let u=0;u<2;++u){r||(await c(this,j),r=c(this,F).transaction(c(this,F).objectStoreNames,t,s),(n=this.log)==null||n.call(this,"IDBTransaction open",t),c(this,A).add(r),C(this,j,new Promise((l,g)=>{r.addEventListener("complete",()=>{var i;(i=this.log)==null||i.call(this,"IDBTransaction complete"),c(this,A).delete(r),l()}),r.addEventListener("abort",()=>{c(this,A).delete(r),g(new Error("transaction aborted"))})})));try{const l=[...r.objectStoreNames].map(g=>[g,this.proxyStoreOrIndex(r.objectStore(g))]);return await h(Object.fromEntries(l))}catch(l){if(!u&&Ke.has(l.name)){(f=this.log)==null||f.call(this,`${l.name}, retrying`),r=null;continue}throw l}}};let G=X;function He(d){return new Promise((h,t)=>{d.onsuccess=()=>h(d.result),d.onerror=()=>t(d.error)})}export{se as IDBBatchAtomicVFS,G as IDBContext};
